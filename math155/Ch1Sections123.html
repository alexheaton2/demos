<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Guide: Lang's Calculus Sections 1.1-1.3</title>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --success: #27ae60;
            --bg-light: #f8f9fa;
            --text-dark: #333;
            --card-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-dark);
            margin: 0;
            padding: 0;
            background-color: #fdfdfd;
        }

        header {
            background: var(--primary);
            color: white;
            padding: 2rem 1rem;
            text-align: center;
            margin-bottom: 2rem;
        }

        header h1 { margin: 0; font-size: 2.5rem; }
        header p { opacity: 0.9; font-size: 1.1rem; margin-top: 0.5rem; }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        .section-title {
            border-bottom: 3px solid var(--secondary);
            padding-bottom: 0.5rem;
            margin-top: 3rem;
            margin-bottom: 1.5rem;
            color: var(--primary);
        }

        .subsection {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: var(--card-shadow);
            border-left: 5px solid var(--secondary);
        }

        .subsection h3 { margin-top: 0; color: var(--primary); }

        .interactive-box {
            background: var(--bg-light);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1.5rem;
        }

        .interactive-header {
            font-weight: bold;
            color: #555;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .interactive-header span {
            background: #e0e0e0;
            font-size: 0.8rem;
            padding: 2px 8px;
            border-radius: 4px;
        }

        canvas {
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
            max-width: 100%;
        }

        .controls {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        button {
            background: var(--secondary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }

        button:hover { background: #2980b9; }
        
        button.active { background: var(--primary); }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .math-display {
            font-family: 'Courier New', Courier, monospace;
            background: #333;
            color: #4ade80;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            text-align: center;
        }

        /* 7-Space Visualizer Specifics */
        .bar-chart {
            display: flex;
            align-items: flex-end;
            height: 150px;
            gap: 5px;
            padding-top: 20px;
        }
        .bar {
            flex: 1;
            background: var(--secondary);
            transition: height 0.3s;
            position: relative;
            border-radius: 4px 4px 0 0;
        }
        .bar:hover { background: var(--accent); }
        .bar-label {
            position: absolute;
            bottom: -25px;
            width: 100%;
            text-align: center;
            font-size: 0.7rem;
            transform: rotate(-45deg);
            white-space: nowrap;
        }
        .inputs-7d {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 5px;
            margin-top: 30px;
        }
        .inputs-7d input {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

    </style>
</head>
<body>

<header>
    <h1>Lang's Calculus of Several Variables</h1>
    <p>Interactive Guide for Sections 1.1, 1.2, and 1.3</p>
</header>

<div class="container">

    <!-- PART 0 -->
    <h2 class="section-title">Part 0: Concise & Intuitive Overview</h2>
    <p>Before diving into formulas, let's establish the geometric and algebraic landscape of multivariable calculus as presented in Chapter 1.</p>

    <!-- 0.1 n-Space -->
    <div class="subsection">
        <h3>The Stage: n-Space (Rⁿ)</h3>
        <p>In single-variable calculus, we work on a line (R¹). In multivariable calculus, we generalize this to lists of numbers.</p>
        <ul>
            <li>A pair (x, y) represents a location in 2D planes.</li>
            <li>A triple (x, y, z) represents a location in 3D space.</li>
            <li>A list of n numbers (x₁, ..., xₙ) represents a location in n-dimensional space.</li>
        </ul>
        <p>While we cannot visualize 4D or 5D space directly, the <strong>algebra</strong> works exactly the same way. A point is simply an ordered list of coordinates.</p>
        
        <div class="interactive-box">
            <div class="interactive-header">Visualizer: The List Concept <span>Interactive</span></div>
            <p>Below is a representation of a point in 5-dimensional space. Adjust the sliders to change the "coordinates".</p>
            <div style="display:flex; justify-content: space-around; align-items: flex-end; height: 100px;" id="nSpaceVis">
                <!-- Generated by JS -->
            </div>
            <div class="math-display" id="nSpaceText">P = (0, 0, 0, 0, 0)</div>
        </div>
    </div>

    <!-- 0.2 Points vs Vectors -->
    <div class="subsection">
        <h3>Points vs. Vectors</h3>
        <p>We use the same notation, a list of numbers like (1, 2), for two distinct concepts:</p>
        <ol>
            <li><strong>Points:</strong> Fixed locations in space (dots).</li>
            <li><strong>Vectors:</strong> Movements or displacements (arrows).</li>
        </ol>
        <p><strong>Key Difference:</strong> You can add movements (vectors) to get a net movement. Adding locations (points) doesn't make intuitive sense, though we compute it the same way algebraically.</p>
        
        <div class="interactive-box">
            <div class="interactive-header">Visualizer: Point vs Vector Toggle <span>Interactive</span></div>
            <canvas id="canvasPV" width="600" height="300"></canvas>
            <div class="controls">
                <button onclick="app.togglePV('point')" id="btnPoint" class="active">View as Point</button>
                <button onclick="app.togglePV('vector')" id="btnVector">View as Vector</button>
            </div>
            <p style="text-align:center; font-size:0.9rem; color:#666;">Drag the blue dot around the canvas.</p>
        </div>
    </div>

    <!-- 0.3 Located Vectors -->
    <div class="subsection">
        <h3>Located Vectors</h3>
        <p>Sometimes we want to describe a movement between two points, say A and B, where neither is the origin. We call this a <strong>located vector AB</strong>.</p>
        <ul>
            <li>Physically, this is an arrow starting at A and ending at B.</li>
            <li>Algebraically, this corresponds to the difference B - A (Final minus Initial).</li>
            <li>Two located vectors are <strong>equivalent</strong> if they represent the same displacement.</li>
        </ul>

        <div class="interactive-box">
            <div class="interactive-header">Visualizer: Equivalent Displacement <span>Interactive</span></div>
            <canvas id="canvasLoc" width="600" height="300"></canvas>
            <div class="controls">
                <button onclick="app.resetLoc()">Reset Points</button>
                <label><input type="checkbox" id="checkShowOrigin" onchange="app.drawLoc()"> Show Equivalent at Origin (B-A)</label>
            </div>
            <div class="math-display" id="locText">Calculations...</div>
            <p style="text-align:center; font-size:0.9rem; color:#666;">Drag Points A (Start) and B (End).</p>
        </div>
    </div>

    <!-- 0.4 Scalar Product -->
    <div class="subsection">
        <h3>The Scalar Product (The Geometry Detector)</h3>
        <p>How do we do geometry (angles, lengths, perpendicularity) using only lists of numbers? We use the <strong>Scalar Product</strong> (or Dot Product).</p>
        <ul>
            <li>It takes two vectors and returns a single number (a scalar).</li>
            <li>If A · B = 0, the vectors are <strong>perpendicular</strong>.</li>
            <li>If A · B > 0, they point generally in the same direction.</li>
            <li>If A · B < 0, they point generally in opposite directions.</li>
        </ul>

        <div class="interactive-box">
            <div class="interactive-header">Visualizer: The Geometry Detector <span>Interactive</span></div>
            <canvas id="canvasDot" width="600" height="300"></canvas>
            <div class="math-display" id="dotText">A · B = ?</div>
            <p style="text-align:center; font-size:0.9rem; color:#666;">Drag the tips of the Red and Blue vectors.</p>
        </div>
    </div>

    <!-- PART 1 -->
    <h2 class="section-title">Part 1: Illustrative Examples</h2>
    <p>The following examples illustrate the mechanics of the subject intuitively, without heavy formal definitions.</p>

    <!-- Example 1 -->
    <div class="subsection">
        <h3>Example 1: Dimensions beyond 3</h3>
        <p><strong>Context:</strong> Consider an economic model listing expenditures of 7 different industries (Steel, Auto, Farm, Fish, Chemicals, Clothing, Transportation).</p>
        <p>Here, the "point" exists in 7-dimensional space. A "dimension" is simply a slot in a list of data.</p>
        
        <div class="interactive-box">
            <div class="interactive-header">7-Dimensional Space <span>Interactive</span></div>
            <div class="bar-chart" id="chart7d">
                <!-- Bars generated by JS -->
            </div>
            <div class="inputs-7d" id="inputs7d">
                <!-- Inputs generated by JS -->
            </div>
            <div class="math-display" id="text7d">P = (...)</div>
        </div>
    </div>

    <!-- Example 2 & 3 -->
    <div class="subsection">
        <h3>Example 2 & 3: Vector Addition</h3>
        <p><strong>Context:</strong> How do we add two points (vectors) together?</p>
        <p><strong>Algebraic:</strong> Add corresponding slots. (1,2) + (-3,5) = (-2, 7).</p>
        <p><strong>Geometric:</strong> A + B is the diagonal of the parallelogram formed by A and B starting from the origin.</p>

        <div class="interactive-box">
            <div class="interactive-header">Parallelogram Law <span>Interactive</span></div>
            <canvas id="canvasAdd" width="600" height="300"></canvas>
            <div class="controls">
                <label><input type="checkbox" id="checkPara" checked onchange="app.drawAdd()"> Show Parallelogram</label>
            </div>
            <div class="math-display" id="addText">A + B = Result</div>
        </div>
    </div>

    <!-- Example 4 -->
    <div class="subsection">
        <h3>Example 4: Scalar Multiplication</h3>
        <p><strong>Context:</strong> What does multiplying by a number do visually?</p>
        <p>Multiplying by <strong>c</strong> scales the length. If c is negative, it also reverses the direction.</p>

        <div class="interactive-box">
            <div class="interactive-header">Scaling Vectors <span>Interactive</span></div>
            <canvas id="canvasScale" width="600" height="300"></canvas>
            <div class="controls">
                <div class="slider-container">
                    <label>Scalar (c):</label>
                    <input type="range" id="sliderScale" min="-3" max="3" step="0.1" value="2" oninput="app.updateScale()">
                    <span id="scaleValue">2.0</span>
                </div>
            </div>
            <div class="math-display" id="scaleText">c * A = Result</div>
        </div>
    </div>

    <!-- Example 5 & 6 -->
    <div class="subsection">
        <h3>Example 5 & 6: Located Vectors & Parallelism</h3>
        <p><strong>Context:</strong> Checking if two separated arrows represent the same movement or are parallel.</p>
        <p>Let P and Q form one vector. Let A and B form another. We check their algebraic differences (B-A) and (Q-P).</p>

        <div class="interactive-box">
            <div class="interactive-header">Comparing Displacements <span>Interactive</span></div>
            <canvas id="canvasParallel" width="600" height="350"></canvas>
            <div class="controls">
                <button onclick="app.randomizeParallel()">Randomize Vectors</button>
                <button onclick="app.makeParallel()">Make Parallel</button>
            </div>
            <div class="math-display" id="parallelText">Status: ...</div>
            <p style="text-align:center; font-size:0.9rem; color:#666;">Drag A, B, P, or Q.</p>
        </div>
    </div>

     <!-- Example 7 & 8 -->
     <div class="subsection">
        <h3>Example 7 & 8: Scalar Product Calculation</h3>
        <p><strong>Context:</strong> Calculating the precise number. A · B = (x₁)(x₂) + (y₁)(y₂).</p>
        <p><strong>Check:</strong> If result is 0, they are orthogonal.</p>

        <div class="interactive-box">
            <div class="interactive-header">Dot Product Calculator <span>Interactive</span></div>
            <div style="display:flex; justify-content: center; gap: 2rem; margin-bottom: 1rem;">
                <div>
                    <strong>Vector A:</strong><br>
                    x: <input type="number" id="ax" value="1" style="width:50px" oninput="app.calcDot()">
                    y: <input type="number" id="ay" value="2" style="width:50px" oninput="app.calcDot()">
                </div>
                <div>
                    <strong>Vector B:</strong><br>
                    x: <input type="number" id="bx" value="-2" style="width:50px" oninput="app.calcDot()">
                    y: <input type="number" id="by" value="1" style="width:50px" oninput="app.calcDot()">
                </div>
            </div>
            <canvas id="canvasCalc" width="400" height="200"></canvas>
            <div class="math-display" id="calcResult">Calculation...</div>
        </div>
    </div>

</div>

<script>
/**
 * Application Logic
 * Encapsulates all canvas drawing and interaction logic.
 */
const app = {
    // Configuration
    gridSize: 20,
    axisColor: '#333',
    gridColor: '#eee',
    
    // State
    pvMode: 'point',
    pvPoint: {x: 3, y: 2},
    
    locA: {x: -4, y: -2},
    locB: {x: -1, y: 3},
    
    dotA: {x: 4, y: 0},
    dotB: {x: 0, y: 3},

    addA: {x: 3, y: 1},
    addB: {x: 1, y: 3},

    scaleA: {x: 2, y: 1},
    scaleVal: 2.0,

    parP: {x: -5, y: 2},
    parQ: {x: -2, y: 4},
    parA: {x: 2, y: -2},
    parB: {x: 5, y: 0},

    // 7D State
    dims7: [1000, 800, 550, 300, 700, 200, 900],
    labels7: ['Steel', 'Auto', 'Farm', 'Fish', 'Chem', 'Cloth', 'Trans'],

    // 5D Overview State
    dims5: [2, 5, 8, 3, 6],

    // Initialization
    init() {
        this.setupInteractions();
        
        // Initial Draws
        this.drawPV();
        this.drawLoc();
        this.drawDot();
        this.init7D();
        this.init5D();
        this.drawAdd();
        this.drawScale();
        this.drawParallel();
        this.calcDot();
    },

    // ---------------------------------------------------------
    // Helper: Coordinate Transformations
    // ---------------------------------------------------------
    // Canvas Center is (0,0) in math coords. Y is flipped. Scale is 30px per unit.
    toScreen(canvas, x, y) {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const scale = 30;
        return {
            x: cx + x * scale,
            y: cy - y * scale
        };
    },

    toMath(canvas, sx, sy) {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const scale = 30;
        return {
            x: (sx - cx) / scale,
            y: -(sy - cy) / scale
        };
    },

    // ---------------------------------------------------------
    // Helper: Drawing Utils
    // ---------------------------------------------------------
    drawGrid(ctx, w, h) {
        ctx.clearRect(0, 0, w, h);
        ctx.beginPath();
        ctx.strokeStyle = this.gridColor;
        ctx.lineWidth = 1;
        
        const cx = w/2;
        const cy = h/2;
        const scale = 30;

        // Vertical lines
        for(let x = cx; x < w; x += scale) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
        for(let x = cx; x > 0; x -= scale) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
        
        // Horizontal lines
        for(let y = cy; y < h; y += scale) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
        for(let y = cy; y > 0; y -= scale) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
        ctx.stroke();

        // Axes
        ctx.beginPath();
        ctx.strokeStyle = this.axisColor;
        ctx.lineWidth = 2;
        ctx.moveTo(cx, 0); ctx.lineTo(cx, h);
        ctx.moveTo(0, cy); ctx.lineTo(w, cy);
        ctx.stroke();
    },

    drawArrow(ctx, fromX, fromY, toX, toY, color, label) {
        const headlen = 10; 
        const dx = toX - fromX;
        const dy = toY - fromY;
        const angle = Math.atan2(dy, dx);

        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.stroke();

        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
        ctx.fill();

        if(label) {
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(label, toX + 10, toY - 10);
        }
    },

    drawDot(ctx, x, y, color, label) {
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(x, y, 6, 0, Math.PI*2);
        ctx.fill();
        if(label) {
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(label, x + 10, y - 10);
        }
    },

    // ---------------------------------------------------------
    // Logic: Points vs Vectors
    // ---------------------------------------------------------
    togglePV(mode) {
        this.pvMode = mode;
        document.getElementById('btnPoint').className = mode === 'point' ? 'active' : '';
        document.getElementById('btnVector').className = mode === 'vector' ? 'active' : '';
        this.drawPV();
    },
    drawPV() {
        const c = document.getElementById('canvasPV');
        const ctx = c.getContext('2d');
        this.drawGrid(ctx, c.width, c.height);

        const p = this.toScreen(c, this.pvPoint.x, this.pvPoint.y);
        const o = this.toScreen(c, 0, 0);

        if(this.pvMode === 'vector') {
            this.drawArrow(ctx, o.x, o.y, p.x, p.y, '#3498db', `P(${this.pvPoint.x.toFixed(1)}, ${this.pvPoint.y.toFixed(1)})`);
        } else {
            this.drawDot(ctx, p.x, p.y, '#3498db', `P(${this.pvPoint.x.toFixed(1)}, ${this.pvPoint.y.toFixed(1)})`);
        }
    },

    // ---------------------------------------------------------
    // Logic: Located Vectors
    // ---------------------------------------------------------
    resetLoc() {
        this.locA = {x: -4, y: -2};
        this.locB = {x: -1, y: 3};
        this.drawLoc();
    },
    drawLoc() {
        const c = document.getElementById('canvasLoc');
        const ctx = c.getContext('2d');
        this.drawGrid(ctx, c.width, c.height);

        const showOrigin = document.getElementById('checkShowOrigin').checked;
        
        const sA = this.toScreen(c, this.locA.x, this.locA.y);
        const sB = this.toScreen(c, this.locB.x, this.locB.y);

        // Draw Located Vector AB
        this.drawArrow(ctx, sA.x, sA.y, sB.x, sB.y, '#e74c3c', '');
        this.drawDot(ctx, sA.x, sA.y, '#333', 'A');
        this.drawDot(ctx, sB.x, sB.y, '#333', 'B');

        // Calculate Components
        const dx = this.locB.x - this.locA.x;
        const dy = this.locB.y - this.locA.y;

        if(showOrigin) {
            const o = this.toScreen(c, 0, 0);
            const dest = this.toScreen(c, dx, dy);
            
            ctx.save();
            ctx.setLineDash([5, 5]);
            this.drawArrow(ctx, o.x, o.y, dest.x, dest.y, '#3498db', 'B-A');
            ctx.restore();
        }

        const txt = document.getElementById('locText');
        txt.innerHTML = `A=(${this.locA.x.toFixed(1)}, ${this.locA.y.toFixed(1)}) <br> B=(${this.locB.x.toFixed(1)}, ${this.locB.y.toFixed(1)}) <br> Vector = (${dx.toFixed(1)}, ${dy.toFixed(1)})`;
    },

    // ---------------------------------------------------------
    // Logic: Dot Product
    // ---------------------------------------------------------
    drawDot() {
        const c = document.getElementById('canvasDot');
        const ctx = c.getContext('2d');
        this.drawGrid(ctx, c.width, c.height);

        const o = this.toScreen(c, 0, 0);
        const sA = this.toScreen(c, this.dotA.x, this.dotA.y);
        const sB = this.toScreen(c, this.dotB.x, this.dotB.y);

        this.drawArrow(ctx, o.x, o.y, sA.x, sA.y, '#e74c3c', 'A');
        this.drawArrow(ctx, o.x, o.y, sB.x, sB.y, '#3498db', 'B');

        const dot = (this.dotA.x * this.dotB.x) + (this.dotA.y * this.dotB.y);
        const txt = document.getElementById('dotText');
        
        let status = "";
        let color = "#4ade80"; // green
        if (Math.abs(dot) < 0.1) { status = "(Perpendicular)"; color = "#3498db"; }
        else if (dot > 0) { status = "(Same general direction)"; }
        else { status = "(Opposite general direction)"; color = "#e74c3c"; }

        txt.innerHTML = `A · B = ${dot.toFixed(1)} <span style="color:${color}">${status}</span>`;
    },

    // ---------------------------------------------------------
    // Logic: 5D Overview
    // ---------------------------------------------------------
    init5D() {
        const container = document.getElementById('nSpaceVis');
        const text = document.getElementById('nSpaceText');
        container.innerHTML = '';
        
        this.dims5.forEach((val, i) => {
            // Slider wrapper
            const wrap = document.createElement('div');
            wrap.style.display = 'flex';
            wrap.style.flexDirection = 'column';
            wrap.style.alignItems = 'center';
            
            const range = document.createElement('input');
            range.type = 'range';
            range.min = 0; range.max = 10;
            range.value = val;
            range.style.writingMode = 'bt-lr'; /* IE/Edge */
            range.style.webkitAppearance = 'slider-vertical';
            range.style.height = '80px';
            range.oninput = (e) => {
                this.dims5[i] = parseInt(e.target.value);
                this.update5DText();
            };

            const label = document.createElement('span');
            label.innerText = `x${i+1}`;
            label.style.fontSize = '0.8rem';

            wrap.appendChild(range);
            wrap.appendChild(label);
            container.appendChild(wrap);
        });
        this.update5DText();
    },
    update5DText() {
        document.getElementById('nSpaceText').innerText = `P = (${this.dims5.join(', ')})`;
    },


    // ---------------------------------------------------------
    // Logic: 7D Example
    // ---------------------------------------------------------
    init7D() {
        const chart = document.getElementById('chart7d');
        const inputs = document.getElementById('inputs7d');
        chart.innerHTML = '';
        inputs.innerHTML = '';

        this.dims7.forEach((val, i) => {
            // Bar
            const bar = document.createElement('div');
            bar.className = 'bar';
            bar.style.height = (val / 10) + '%'; // Max 1000 roughly
            bar.title = this.labels7[i] + ': ' + val;
            
            const blabel = document.createElement('div');
            blabel.className = 'bar-label';
            blabel.innerText = this.labels7[i];
            bar.appendChild(blabel);
            chart.appendChild(bar);

            // Input
            const inp = document.createElement('input');
            inp.type = 'number';
            inp.value = val;
            inp.step = 50;
            inp.oninput = (e) => {
                this.dims7[i] = parseInt(e.target.value);
                bar.style.height = (this.dims7[i] / 10) + '%';
                bar.title = this.labels7[i] + ': ' + this.dims7[i];
                this.update7DText();
            };
            inputs.appendChild(inp);
        });
        this.update7DText();
    },
    update7DText() {
        document.getElementById('text7d').innerText = `P = (${this.dims7.join(', ')})`;
    },

    // ---------------------------------------------------------
    // Logic: Addition
    // ---------------------------------------------------------
    drawAdd() {
        const c = document.getElementById('canvasAdd');
        const ctx = c.getContext('2d');
        this.drawGrid(ctx, c.width, c.height);

        const showPara = document.getElementById('checkPara').checked;
        const o = this.toScreen(c, 0, 0);
        const sA = this.toScreen(c, this.addA.x, this.addA.y);
        const sB = this.toScreen(c, this.addB.x, this.addB.y);
        
        // Resultant
        const rX = this.addA.x + this.addB.x;
        const rY = this.addA.y + this.addB.y;
        const sR = this.toScreen(c, rX, rY);

        if (showPara) {
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#aaa';
            ctx.beginPath();
            ctx.moveTo(sA.x, sA.y);
            ctx.lineTo(sR.x, sR.y);
            ctx.lineTo(sB.x, sB.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        this.drawArrow(ctx, o.x, o.y, sA.x, sA.y, '#e74c3c', 'A');
        this.drawArrow(ctx, o.x, o.y, sB.x, sB.y, '#3498db', 'B');
        this.drawArrow(ctx, o.x, o.y, sR.x, sR.y, '#27ae60', 'A+B');

        document.getElementById('addText').innerHTML = 
            `(${this.addA.x.toFixed(1)}, ${this.addA.y.toFixed(1)}) + (${this.addB.x.toFixed(1)}, ${this.addB.y.toFixed(1)}) = (${rX.toFixed(1)}, ${rY.toFixed(1)})`;
    },

    // ---------------------------------------------------------
    // Logic: Scaling
    // ---------------------------------------------------------
    updateScale() {
        this.scaleVal = parseFloat(document.getElementById('sliderScale').value);
        document.getElementById('scaleValue').innerText = this.scaleVal.toFixed(1);
        this.drawScale();
    },
    drawScale() {
        const c = document.getElementById('canvasScale');
        const ctx = c.getContext('2d');
        this.drawGrid(ctx, c.width, c.height);

        const o = this.toScreen(c, 0, 0);
        const sA = this.toScreen(c, this.scaleA.x, this.scaleA.y);

        // Original A (Ghost)
        ctx.globalAlpha = 0.3;
        this.drawArrow(ctx, o.x, o.y, sA.x, sA.y, '#333', 'A');
        ctx.globalAlpha = 1.0;

        // Scaled
        const rX = this.scaleA.x * this.scaleVal;
        const rY = this.scaleA.y * this.scaleVal;
        const sR = this.toScreen(c, rX, rY);

        this.drawArrow(ctx, o.x, o.y, sR.x, sR.y, '#e74c3c', 'cA');

        document.getElementById('scaleText').innerHTML = 
            `${this.scaleVal} * (${this.scaleA.x}, ${this.scaleA.y}) = (${rX.toFixed(1)}, ${rY.toFixed(1)})`;
    },

    // ---------------------------------------------------------
    // Logic: Parallel / Located Comparison
    // ---------------------------------------------------------
    randomizeParallel() {
        this.parP = {x: (Math.random()*6-3), y: (Math.random()*4-2)};
        this.parQ = {x: (Math.random()*6-3), y: (Math.random()*4-2)};
        this.parA = {x: (Math.random()*6-3), y: (Math.random()*4-2)};
        this.parB = {x: (Math.random()*6-3), y: (Math.random()*4-2)};
        this.drawParallel();
    },
    makeParallel() {
        // Make AB parallel to PQ (scale by 2 for effect)
        const dx = this.parQ.x - this.parP.x;
        const dy = this.parQ.y - this.parP.y;
        this.parA = {x: 2, y: -2};
        this.parB = {x: 2 + dx, y: -2 + dy};
        this.drawParallel();
    },
    drawParallel() {
        const c = document.getElementById('canvasParallel');
        const ctx = c.getContext('2d');
        this.drawGrid(ctx, c.width, c.height);

        const sP = this.toScreen(c, this.parP.x, this.parP.y);
        const sQ = this.toScreen(c, this.parQ.x, this.parQ.y);
        const sA = this.toScreen(c, this.parA.x, this.parA.y);
        const sB = this.toScreen(c, this.parB.x, this.parB.y);

        this.drawArrow(ctx, sP.x, sP.y, sQ.x, sQ.y, '#e74c3c', 'PQ');
        this.drawArrow(ctx, sA.x, sA.y, sB.x, sB.y, '#3498db', 'AB');
        
        // Draw Points
        this.drawDot(ctx, sP.x, sP.y, '#333', 'P');
        this.drawDot(ctx, sQ.x, sQ.y, '#333', 'Q');
        this.drawDot(ctx, sA.x, sA.y, '#333', 'A');
        this.drawDot(ctx, sB.x, sB.y, '#333', 'B');

        // Math
        const v1x = this.parQ.x - this.parP.x;
        const v1y = this.parQ.y - this.parP.y;
        const v2x = this.parB.x - this.parA.x;
        const v2y = this.parB.y - this.parA.y;

        // Check Parallel (cross product is 0)
        const cross = (v1x * v2y) - (v1y * v2x);
        const isParallel = Math.abs(cross) < 0.1;

        document.getElementById('parallelText').innerHTML = 
            `Q-P = (${v1x.toFixed(1)}, ${v1y.toFixed(1)}) <br> B-A = (${v2x.toFixed(1)}, ${v2y.toFixed(1)}) <br> Parallel? <strong>${isParallel ? 'YES' : 'NO'}</strong>`;
    },

    // ---------------------------------------------------------
    // Logic: Calculator
    // ---------------------------------------------------------
    calcDot() {
        const ax = parseFloat(document.getElementById('ax').value);
        const ay = parseFloat(document.getElementById('ay').value);
        const bx = parseFloat(document.getElementById('bx').value);
        const by = parseFloat(document.getElementById('by').value);

        const c = document.getElementById('canvasCalc');
        const ctx = c.getContext('2d');
        this.drawGrid(ctx, c.width, c.height);
        
        // Draw normalized vectors just for visual direction
        const o = this.toScreen(c, 0, 0);
        const sA = this.toScreen(c, ax, ay);
        const sB = this.toScreen(c, bx, by);
        
        this.drawArrow(ctx, o.x, o.y, sA.x, sA.y, '#e74c3c', 'A');
        this.drawArrow(ctx, o.x, o.y, sB.x, sB.y, '#3498db', 'B');

        const res = (ax*bx) + (ay*by);
        let info = "";
        if(res === 0) info = " (Orthogonal)";
        
        document.getElementById('calcResult').innerText = 
            `(${ax})(${bx}) + (${ay})(${by}) = ${res}${info}`;
    },


    // ---------------------------------------------------------
    // Interactions: Drag & Drop Logic
    // ---------------------------------------------------------
    setupInteractions() {
        // Register drag handlers for specific canvases and point targets
        this.attachDrag('canvasPV', (pos) => { this.pvPoint = pos; this.drawPV(); });
        
        this.attachDrag('canvasLoc', (pos, isStart) => {
            // Simple heuristic: closest point moves
            const d1 = Math.hypot(pos.x - this.locA.x, pos.y - this.locA.y);
            const d2 = Math.hypot(pos.x - this.locB.x, pos.y - this.locB.y);
            if (d1 < d2) this.locA = pos;
            else this.locB = pos;
            this.drawLoc();
        });

        this.attachDrag('canvasDot', (pos) => {
            const d1 = Math.hypot(pos.x - this.dotA.x, pos.y - this.dotA.y);
            const d2 = Math.hypot(pos.x - this.dotB.x, pos.y - this.dotB.y);
            if (d1 < d2) this.dotA = pos;
            else this.dotB = pos;
            this.drawDot();
        });

        this.attachDrag('canvasAdd', (pos) => {
            const d1 = Math.hypot(pos.x - this.addA.x, pos.y - this.addA.y);
            const d2 = Math.hypot(pos.x - this.addB.x, pos.y - this.addB.y);
            if (d1 < d2) this.addA = pos;
            else this.addB = pos;
            this.drawAdd();
        });

        this.attachDrag('canvasScale', (pos) => {
            this.scaleA = pos;
            this.drawScale();
        });
        
        this.attachDrag('canvasParallel', (pos) => {
            // Find closest of 4 points
            const points = [this.parP, this.parQ, this.parA, this.parB];
            let closest = 0;
            let minDist = 999;
            points.forEach((p, i) => {
                const d = Math.hypot(pos.x - p.x, pos.y - p.y);
                if(d < minDist) { minDist = d; closest = i; }
            });
            
            // Update
            if (closest === 0) this.parP = pos;
            if (closest === 1) this.parQ = pos;
            if (closest === 2) this.parA = pos;
            if (closest === 3) this.parB = pos;
            this.drawParallel();
        });
    },

    attachDrag(canvasId, callback) {
        const canvas = document.getElementById(canvasId);
        let isDragging = false;

        const getPos = (e) => {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return this.toMath(canvas, clientX - rect.left, clientY - rect.top);
        };

        const start = (e) => { isDragging = true; callback(getPos(e)); };
        const move = (e) => { 
            if(isDragging) {
                e.preventDefault(); // Prevent scroll on touch
                callback(getPos(e)); 
            }
        };
        const end = () => { isDragging = false; };

        canvas.addEventListener('mousedown', start);
        canvas.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end); // Global mouseup

        canvas.addEventListener('touchstart', start);
        canvas.addEventListener('touchmove', move);
        window.addEventListener('touchend', end);
    }
};

// Start App
window.onload = () => app.init();

</script>

</body>
</html>
